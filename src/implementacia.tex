
\chapter{Implementation of Data Lineage for Frameworks}

In this chapter, we will present our solution of Data Lineage library for Database Frameworks.
We will discuss different problems that came with all the frameworks presented in chapter \ref{frameworks}.

\section{Interface}

\section{JDBC \label{implementation:jdbc}}

Implementation of Data Lineage for standard JDBC is done using the library.
\TODO{Popisat plugin}




\subsection{DataSource \label{implementation:dataSource}}

Database vendors usually provide \Code{DataSource} implementation, which still
need some configuration about database - url, credentials and probably much more.

To identify target database, we need information about url and username. These properties
are usually set to \Code{DataSource} objects and from these calls, we can get
their values.




\section{Spring JDBC Framework}

Spring JDBC Framework comes with approach of \Code{Callbacks}. Library handles
all boilerplate code and calls user defined callback objects to do its job
and after finishing it, framework handles closing all resources that are not needed anymore.

When we looked to implementation of \Code{JdbcTemplate} class, we found out
that database calls are actually made only by 4 out of about 50 of its methods.
All the other methods only use them when executing queries.



\subsection{Callbacks}

\TODO{Funguju?}

As we said, callbacks are used just to wrap application logic and
separate it from the code for opening/closing connections, etc,
as was shown by previous example \ref{code:jdbcTemplate}.

We need a way how to say to analysis library, that we want to
analyse that callback method. For that purpose, we use
field \Code{callbackMethodsToAnalyze} from interface. \TODO{referencia na interface}
All callbacks have the method, that is called in execution
and we just leave analysis library to analyse it and return
its data flow. After that, we append the resulted flow
to flow of our handled method.

We will demonstrate it on simple example \ref{code:jdbcTemplate:callbacks}
where insert statement is executed in callback method.

\InsertCode{h}{code/jdbcTemplate-callbacks}

After data lineage of \Code{insertValue()} method is done,
we would like to know, that insert statement was executed there.
However, analysis library does not know, that inside
\Code{jdbcTemplate.execute()} call
the \Code{doInStatement} method of \Code{InsertCallback} is called.

The solution for it is, that when we are handling
\Code{jdbcTemplate.execute()} for the first time, we tell library,
that we want to analyse that \Code{doInStatement} call.
The next time we already have all the information
about data lineage in the \Code{doInStatement}
and therefore we can propagate it to a result of
\Code{jdbcTemplate.execute()} call.




\section{MyBatis}

In chapter \ref{frameworks:myBatis} we showed classic use case of loading data from database.
Now, we present solution of creating data lineage for this framework.



\subsection{Mapper interfaces}

To find all the mappers, we iterate all classes in WALA \Code{IClassHierarchy}.
We are searching for interfaces with methods annotated with MyBatis annotations,
or interfaces for which XML mapper definition exists.



\subsubsection{XML mapper files}

XML mapper file has same name as interface (but .xml extension is used instead of .java),
and lays in same directory.

We made a parser of such a XML files, that can get information about SQL statements
and column to property mapping.
MyBatis provide rich feature set for XML mappers.
We will describe how mappers are defined and some of the advanced features
that we are handling.

Basic mapper, which example was showed in \ref{code:mybatis:mapper:xml} contains of SQL statement
with defined \Code{ResultMap} when needed. MyBatis use tags
\Code{<select>}, \Code{<insert>}, \Code{<delete>} and \Code{<update>}
for storing SQLs and \Code{<resultMap>} for mapping which is divided into column-to-property
mapping pairs.

From more advanced features, MyBatis supports reusable fragmets. It means that
one can define some fragment of SQL and reuse it in more queries.
Each fragment has its own ID, so it is easy to find correct one and include it into query.

Another feature is dynamic SQLs, where queries are created dynamically
as some conditions hold. As we do not know which conditions are valid
at runtime, we made simplification that we always use first branch
that we see in code.
\TODO{Ukazat priklad kodu a jeho vystup}



\subsubsection{Annotated mapper classes}

When mappers use annotations, it is quite simple to get all data needed
from WALA. We know, that SQL statement is always stored in annotations
\Code{@Select}, \Code{@Insert}, \Code{@Delete} or \Code{@Update}
and queries are stored in plain \Code{String} array.
Queries can also contain dynamic SQL as in XML definitions.

For mapping result object the \Code{@Results} is used with \Code{@Result}
for every column to object property mapping definition.
Mapping can be done using \Code{@ConstructorArgs}, when columns are mapped
to arguments of a constructor. In that case, we unfortunately do not know
name of target property, as in constructor arbitrary code can be executed\footnote{
  Arbitrary code can be executed also in setters, but it is usually used
  just as setting new reference to property.
  \TODO{Mozno nejake ine vysvetlenie}
}.

When calling database procedure with some output arguments,
framework can fill result values into method arguments.
It can be \Code{Map<String, TargetClass>} object (where mapper reference to key to that map),
or any arbitrary object (where mapper reference field, in which result will be stored).
\TODO{Viac k vystupnym argumentom?}

There also exists more advanced features of MyBatis when using annotations\footnote{
  Such as using provider classes to create SQL queries (\Code{@SelectProvider}, $\ldots$),
  generating IDs from sequence (\Code{@SelectKey}) and using them in queries,
  generating maps from objects (\Code{@MapKey}),
  associations for attribute classes (\Code{@One} or \Code{@Many}),
  mixing XML and annotation mappers (e.g. define \Code{<resultMap>} in XML and reference it
  using \Code{@ResultMap} annotation)}
but we do not handle them. All of them can be added as new functionality in next development,
if needed.




\subsection{Database connection configuration}

Configuration of MyBatis can be done in two ways, using XML configuration file
or in Java using \Code{Configuration} class. Second way needs no more attention,
as we use \Code{DataSource} classes that are already handled in section \ref{implementation:dataSource}.

To handle XML configuration, we need parse configuration file and find \Code{<dataSource>}
section and its properties \Code{driver}, \Code{url} and \Code{username}. All this
information we need for identifying target database.




\section{Kafka}

In section \ref{frameworks:kafka} we demonstrate main use cases
for manipulating with data (producing or consuming) using Kafka framework.
In this section, we show how data lineage for these examples can be done
using our library. In our work, we concerned only on Consumer and Producer APIs,
as the other two (Stream and Connector APIs) are much more advanced to use.

\TODO{Co tam blizsie popisat, ked je to viac menej priamociare
- trebalo iba osetrit par metod ktore manipuluju s datami - send() a poll()
a par metod ktore nastavovali topic.. Zaujimave moze byt parsovanie
Properties suboru}


