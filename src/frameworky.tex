
\chapter{Overview of database frameworks in java}

In this chapter, we will analyse some of database frameworks that are mainly used
to connect to databases and load data to java applications.

For these frameworks we try tu ilustrate use case, when we try to load
class $DatabaseValue$ \ref{code:model} from database with structure as in \ref{code:db}.

\input{code/model}
\input{code/db}





\section{JDBC}

For accessing database in java application, there exists standard Java Database Connectivity (JDBC) API,
which is described in more detail in \citet{JDBC_OVERVIEW}.

Database vendors ususally provide JDBC API implementation. API is generic, so
there should be no difference for connecting to different database types.

There are few interfaces in \citet{java.sql} package controlling database calls.
\begin{itemize}
  \item Connection
  \item Statement, PreparedStatement, CallableStatement
  \item ResultSet
\end{itemize}

$Connection$ object should hold database connection and through this connection
database queries can be executed using $*Statement$ calls.
When some data are returned to application from statement, it is done
through $ResultSet$.

Getting connection to database is through $DriverManager$, or from JDBC 2.0
it can be done using $DataSource$ and it is now the preferred way of connecting to database.

In the example \ref{code:jdbc}, we will show example of loading data from Oracle database.

\input{code/jdbc}

% TODO nejak rozlisovanie pisma pre dane konstanty
On lines \ref{code:jdbc:dataSource:begin}--\ref{code:jdbc:dataSource:end} we instruct application
to connect to database that can be found in url jdbc:oracle:thin:@//192.168.0.16:1521/orcl,
to use User as user and Password as password.
Then on lines \ref{code:jdbc:prepareStatement:begin}--\ref{code:jdbc:prepareStatement:end}
database query is created to select just rows matching $id$ argument.
The query is then executed on line \ref{code:jdbc:executeQuery} and then
result is mapped from $ResultSet$ to our $DatabaseValue$ model and then it is returned on line \ref{code:jdbc:return}.

As you can see, there is huge amount of boilerplate code (catch-finally blocks) for closing every JDBC API object,
as exceptions can be thrown from all calls as we need to free all database resources that we do not need anymore.

From Java 7, try-with-resources can be used with result, that all finally blocks can be removed - resources
(Connection, PreparedStatement, ResultSet) are automatically closed after finishing block.
This is ilustrated in example \ref{code:jdbc-try-with-resources}.

\input{code/jdbc-try-with-resources}




\section{Spring JDBC Framework}
\citet{SpringJDBC} Framework is extension above JDBC API and tries to help users to code only
parts with application logic and it removes much of the boilerplate code.
From next list, only italicized lines need to be coded by user:
\begin{itemize}
  \item Define connection parameters
  \item Open the connection
  \item \textit{Specify the statement}
  \item Prepare and execute the statement
  \item Set up the loop to iterate through the results (if any)
  \item \textit{Do the work for each iteration}
  \item Process any exception
  \item Handle transactions
  \item Close the connection   
\end{itemize}
Before Java 7, coding in standard JDBC tend to be errorneus because of forgetting to close
database resources and boilerplate code does not help in readability of code.
These problems are removed using Spring JDBC Framework, as can be seen in example \ref{code:jdbcTemplate}.
Example shows, how can be loaded single row from database.

\input{code/jdbcTemplate}





\section{MyBatis}
\section{Hibernate}
\section{Kafka}

