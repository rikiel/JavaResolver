
\chapter{Static Analysis \label{chapter:analysis}}

\TODO{ \\
  -- Co je staticka analyza \\
  -- Rozdiel od dynamickej verzie \\
  -- Naco a kedy sa vyuziva \\
  -- Ake su jej obmedzenia \\
  -- Ako ju mozeme vyuzit v nasej praci \\
}

In this chapter, we will introduce concept of static analysis,
its possible applications and its limitations.

\section{Program Analysis}

\textbf{Program analysis} is the process of automatically analyzing the behavior
of computer programs. There are two approaches of such analysis:
\begin{itemize}
  \item \textbf{Dynamic program analysis} is performed during program runtime.
    To perform dynamic program analysis, both executable program
    and its inputs are required. To be effective, the target program
    must be executed with sufficient test inputs, as its results
    are limited only to observed executions of the analyzed program.
  \item \textbf{Static program analysis} is the program analysis that is actually
    performed without executing program. The analysis is usually
    performed on the program source code, or bytecode.
    Results of static program analysis include all execution branches of
    analysed program.

    Static program analysis technique is very popular. It is thanks
    to its speed, reliability and sometimes it is the only possible
    way for complex systems in reasonable time.
    It is is often used to detect program errors, such as
    security vulnerabilities or performance optimizations.
\end{itemize}

\textbf{Data flow analysis} is a technique for gathering information about
all possible values of variables during program execution.



\section{WALA Framework \label{chapter:analysis:wala}}

The T. J. Watson Libraries for Analysis, the \citet{WalaFramework},
is a framework for static and dynamic analysis capabilities for Java
bytecode and related languages.

The main goals of WALA Framework are:
\begin{itemize}
  \item Robustness
  \item Efficiency
  \item Extensibility
\end{itemize}

The key features WALA Framework provides are:
\begin{itemize}
  \item Pointer analysis
  \item Class hierarchy
  \item Call graph
  \item Interprocedural dataflow analysis
  \item Context-sensitive slicing
\end{itemize}

We describe some of the features in next sections.



\subsection{Pointer analysis}

\citet{PointerAnalysis} define \textbf{pointer analysis},
or \textbf{points-to analysis} respectively, as a static program analysis that
determines information on the values of pointer variables or expressions.
It is near-synonym of \textbf{alias analysis} that use \citet{AliasAnalysis}.
Pointer analysis typically answer question
\uvodzovky{what objects can a variable point to?},
whereas alias analysis focus on closely related question
\uvodzovky{can a pair of variables point to the same object?}.




\subsubsection{Flow and Context Sensitivity}

Flow sensitivity refers to ability of an analysis to take control flow
into account when analyzing a program.
In case, analysis considers statement ordering, it is called \textbf{flow-sensitive},
otherwise it is \textbf{flow-insensitive} analysis.

Contex sensitivity can be taken into account in an interprocedural analysis and
then we call it \textbf{contex-sensitive}. Otherwise, when calling context is ommited,
such an analysis is called \textbf{context-insensitive}.




\subsubsection{Andersen's algorithms}

\TODO{Popisat, ak ho pouzivame aj v nasej analyze: \\
http://wala.sourceforge.net/wiki/index.php/UserGuide:PointerAnalysis}




\subsection{Class hierarchy}

A \textbf{class hierarchy} is a structure for set of classes
of the analyzed program. There is also information about the used
programming language and the relationships between such classes.

Such relations in programs written in Java language are \Code{implements} and \Code{extends}
relations.

For each class, there is also collection of methods. Methods can be declared in the
class, or inherited from parent.



\subsection{Call Graph}

A \textbf{call graph} represents calling relationships between subroutines
in an analysed computer program. The nodes represents procedures and each
directed edge represents procedure calls.

When used in context-sensitive manner, which means that for each procedure 
the graph contains a separate node for each call stack that procedure can be
activated with.




\section{Symbolic Analysis Library}

\textbf{Symbolic analysis library} is a library for computing flow of information
in Java program - the data lineage.
Symbolic analysis library was introduced in \citet{ParizekHybridAnalysis}
and in the research in that field continues and its results will be published
in a short time in \citet{ParizekBUBEN}.

The library uses static analysis techniques to construct call graph and
for each invocation context (parameter values) of method,
it computes its summary based on symbolic bytecode interpretation.

The bytecode analysis is done using \citet{WalaFramework}
that was described in section \ref{chapter:analysis:wala}.

Bytecode interpreter performs linear traversal of the method bytecode instructions
and computes various information for symbolic variables and constant expressions.

The \citet{ParizekBUBEN} defines method summaries as a data structure
that contains the following information:
\begin{itemize}
  \item A list of all object fields possibly updated in the method.
  \item A list of all possibly updated static fields.
  \item A list of all array elements updated in the method.
  \item For each updated field and array element, a list of possible new values.
  \item A boolean flag saying whether the method may return a value corresponding
    to its arguments, and indexes of the respective arguments.
  \item A set of all objects newly allocated in the method, including arrays.
  \item A boolean flag saying whether the method may return a new object.
  \item A set of all possible return values.
  \item A list of fields and array elements updated outside of any code region that is
    protected by a lock or through another mechanism of thread synchronization.
\end{itemize}



\subsection{Symbolic Analysis Algorithm}

The symbolic analysis algorithm for computing static method summaries use:
\begin{enumerate}
  \item A \textbf{fixpoint worklist algorithm} over the list of all reachable methods.
  \item A \textbf{linear symbolic interpretation} of the bytecode of methods.
\end{enumerate}

The library is iteratively updating its method summaries until the fixpoint is reached, i.e.
when summaries are not changing.

Several method invocation contexts (method parameters with their associated data flow information)
are distinguished. When the newly computed summary for a given method is different from the previous
one, all callers and calles of the method are added to the worklist in order to achieve soundness.
The algorithm terminates when the summary of each method captures all its results and side effects.




\subsection{Flow Propagation}

In the previous section we described general algorithm for symbolic analysis.
However, we did not specify, how the flow information is used in practice.




\subsubsection{Library Methods}

As optimizations, library does not process all reachable methods.
It analyses just methods of application code and procedures with special
meaning, that are described in next sections.

For ignored methods, the \textbf{identity} is returned.
The identity function with respect to flow data propagation is defined as
merge of flow data of receiver (the object on which method is called) and
all arguments of that method. The result of that merge is then associated
as flow data of returned value and receiver.




\subsubsection{Strings}

Know the concrete values of the \Code{String} used in application is valuable
when it comes to data lineage of application.
\Code{String}s identify file names that are accessed in application,
or it can be query to database, etc.

However, concrete values are known only when using as literal in the application.
Sometimes, the symbolic analysis cannot determine the precise concrete string value.
It is often when it is loaded from file or database, or after some operations
like \Code{trim}, \Code{substring}, or even concatenation of \Code{String}s.
Then the actual value is in general unknown, but the flow information must be preserved.




\subsubsection{Numeric types}

The idea of concrete values for numeric Java types works as in case
of \Code{String} literals. It is useful to know them, but often
they cannot be determined. Flow information must be preserved after
the operations with the numbers in any case.




\subsubsection{Arrays and Collections}

Arrays and collections are integral parts of Java. In this part we describe how
they are handled in propagation of flow.

The basic approach is not to distinguish individual items and use just one
abstract element summary. In that case, as over-approximation, all possible elements
of a given array or collection are considered.
Complete flow information is also used when creating \Code{java.util.Iterator}
from a collection.

Also, when using \Code{java.util.Map} and \Code{java.util.Properties} classes,
analysis does not distinguish between used keys and corresponding values
and maintains just a single set of flow for the whole class.

When collections of \Code{String}s or numeric values library provides
the information about concrete values stored in collections whenever possible.





\subsection{Identifying the Sources and Sinks of a Data}

Symbolic analysis algorithm, that we describe in previous section is
used to compute data flow in application.
When such sources or sinks are identified, the algorithm would
propagate such data flow.

Now, the problem is to identify the sources and sinks of a data
in the application.




\subsubsection{Java IO}

Java input and output (IO) operations can be used to access data in application.
It can be done through standard application
\Code{System.in}, \Code{System.out} and \Code{System.err},
where they are identified by the name \uvodzovky{System.in}, etc.
or using external files, where its file name identifies the source (or sink respectively).

The library handle both cases and correctly identify
all the read and write operations of such inputs and outputs.

The library focus only to inputs and outpus made by classes in \Code{java.io} package
but also the \Code{java.nio} package would be supported soon.




\subsubsection{JDBC API}

The library also contains implementation for identification of
database reads and writes using plain JDBC API.
The related usage of the JDBC API was already described in section \ref{frameworks:jdbc}.

The library can identify the connection url for the database
that application is connecting to, SQL queries and the columns,
that are read from results in \Code{ResultSet}.

The library focus only to classes in package \Code{java.sql}
therefore \Code{javax.sql} API is not supported.

